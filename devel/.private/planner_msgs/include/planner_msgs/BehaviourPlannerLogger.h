// Generated by gencpp from file planner_msgs/BehaviourPlannerLogger.msg
// DO NOT EDIT!


#ifndef PLANNER_MSGS_MESSAGE_BEHAVIOURPLANNERLOGGER_H
#define PLANNER_MSGS_MESSAGE_BEHAVIOURPLANNERLOGGER_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <std_msgs/Header.h>

namespace planner_msgs
{
template <class ContainerAllocator>
struct BehaviourPlannerLogger_
{
  typedef BehaviourPlannerLogger_<ContainerAllocator> Type;

  BehaviourPlannerLogger_()
    : header()
    , total_time(0.0)
    , planner(false)
    , current_seen_ratio(0.0)
    , exploration_cost(0.0)
    , coverage_cost(0.0)
    , room_belief(0.0)
    , tunnel_belief(0.0)
    , perf_exp(0.0)
    , perf_cov(0.0)
    , delta_seen_surf(0.0)
    , delta_seen_vol(0.0)
    , image_brightness_utility()
    , utility_sparse()
    , utility_dense()
    , utility_corridor()
    , final_scores()  {
    }
  BehaviourPlannerLogger_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , total_time(0.0)
    , planner(false)
    , current_seen_ratio(0.0)
    , exploration_cost(0.0)
    , coverage_cost(0.0)
    , room_belief(0.0)
    , tunnel_belief(0.0)
    , perf_exp(0.0)
    , perf_cov(0.0)
    , delta_seen_surf(0.0)
    , delta_seen_vol(0.0)
    , image_brightness_utility(_alloc)
    , utility_sparse(_alloc)
    , utility_dense(_alloc)
    , utility_corridor(_alloc)
    , final_scores(_alloc)  {
  (void)_alloc;
    }



   typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
  _header_type header;

   typedef float _total_time_type;
  _total_time_type total_time;

   typedef uint8_t _planner_type;
  _planner_type planner;

   typedef float _current_seen_ratio_type;
  _current_seen_ratio_type current_seen_ratio;

   typedef float _exploration_cost_type;
  _exploration_cost_type exploration_cost;

   typedef float _coverage_cost_type;
  _coverage_cost_type coverage_cost;

   typedef float _room_belief_type;
  _room_belief_type room_belief;

   typedef float _tunnel_belief_type;
  _tunnel_belief_type tunnel_belief;

   typedef float _perf_exp_type;
  _perf_exp_type perf_exp;

   typedef float _perf_cov_type;
  _perf_cov_type perf_cov;

   typedef float _delta_seen_surf_type;
  _delta_seen_surf_type delta_seen_surf;

   typedef float _delta_seen_vol_type;
  _delta_seen_vol_type delta_seen_vol;

   typedef std::vector<float, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<float>> _image_brightness_utility_type;
  _image_brightness_utility_type image_brightness_utility;

   typedef std::vector<float, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<float>> _utility_sparse_type;
  _utility_sparse_type utility_sparse;

   typedef std::vector<float, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<float>> _utility_dense_type;
  _utility_dense_type utility_dense;

   typedef std::vector<float, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<float>> _utility_corridor_type;
  _utility_corridor_type utility_corridor;

   typedef std::vector<float, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<float>> _final_scores_type;
  _final_scores_type final_scores;





  typedef boost::shared_ptr< ::planner_msgs::BehaviourPlannerLogger_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::planner_msgs::BehaviourPlannerLogger_<ContainerAllocator> const> ConstPtr;

}; // struct BehaviourPlannerLogger_

typedef ::planner_msgs::BehaviourPlannerLogger_<std::allocator<void> > BehaviourPlannerLogger;

typedef boost::shared_ptr< ::planner_msgs::BehaviourPlannerLogger > BehaviourPlannerLoggerPtr;
typedef boost::shared_ptr< ::planner_msgs::BehaviourPlannerLogger const> BehaviourPlannerLoggerConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::planner_msgs::BehaviourPlannerLogger_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::planner_msgs::BehaviourPlannerLogger_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::planner_msgs::BehaviourPlannerLogger_<ContainerAllocator1> & lhs, const ::planner_msgs::BehaviourPlannerLogger_<ContainerAllocator2> & rhs)
{
  return lhs.header == rhs.header &&
    lhs.total_time == rhs.total_time &&
    lhs.planner == rhs.planner &&
    lhs.current_seen_ratio == rhs.current_seen_ratio &&
    lhs.exploration_cost == rhs.exploration_cost &&
    lhs.coverage_cost == rhs.coverage_cost &&
    lhs.room_belief == rhs.room_belief &&
    lhs.tunnel_belief == rhs.tunnel_belief &&
    lhs.perf_exp == rhs.perf_exp &&
    lhs.perf_cov == rhs.perf_cov &&
    lhs.delta_seen_surf == rhs.delta_seen_surf &&
    lhs.delta_seen_vol == rhs.delta_seen_vol &&
    lhs.image_brightness_utility == rhs.image_brightness_utility &&
    lhs.utility_sparse == rhs.utility_sparse &&
    lhs.utility_dense == rhs.utility_dense &&
    lhs.utility_corridor == rhs.utility_corridor &&
    lhs.final_scores == rhs.final_scores;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::planner_msgs::BehaviourPlannerLogger_<ContainerAllocator1> & lhs, const ::planner_msgs::BehaviourPlannerLogger_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace planner_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::planner_msgs::BehaviourPlannerLogger_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::planner_msgs::BehaviourPlannerLogger_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::planner_msgs::BehaviourPlannerLogger_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::planner_msgs::BehaviourPlannerLogger_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::planner_msgs::BehaviourPlannerLogger_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::planner_msgs::BehaviourPlannerLogger_<ContainerAllocator> const>
  : TrueType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::planner_msgs::BehaviourPlannerLogger_<ContainerAllocator> >
{
  static const char* value()
  {
    return "c3c9c34a8a3952fd0863b37239f93bdd";
  }

  static const char* value(const ::planner_msgs::BehaviourPlannerLogger_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xc3c9c34a8a3952fdULL;
  static const uint64_t static_value2 = 0x0863b37239f93bddULL;
};

template<class ContainerAllocator>
struct DataType< ::planner_msgs::BehaviourPlannerLogger_<ContainerAllocator> >
{
  static const char* value()
  {
    return "planner_msgs/BehaviourPlannerLogger";
  }

  static const char* value(const ::planner_msgs::BehaviourPlannerLogger_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::planner_msgs::BehaviourPlannerLogger_<ContainerAllocator> >
{
  static const char* value()
  {
    return "Header header\n"
"\n"
"float32 total_time\n"
"bool planner\n"
"float32 current_seen_ratio \n"
"float32 exploration_cost\n"
"float32 coverage_cost \n"
"float32 room_belief\n"
"float32 tunnel_belief\n"
"float32 perf_exp\n"
"float32 perf_cov\n"
"float32 delta_seen_surf\n"
"float32 delta_seen_vol\n"
"\n"
"#Hypergame log\n"
"float32[] image_brightness_utility\n"
"float32[] utility_sparse\n"
"float32[] utility_dense\n"
"float32[] utility_corridor\n"
"float32[] final_scores\n"
"================================================================================\n"
"MSG: std_msgs/Header\n"
"# Standard metadata for higher-level stamped data types.\n"
"# This is generally used to communicate timestamped data \n"
"# in a particular coordinate frame.\n"
"# \n"
"# sequence ID: consecutively increasing ID \n"
"uint32 seq\n"
"#Two-integer timestamp that is expressed as:\n"
"# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n"
"# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n"
"# time-handling sugar is provided by the client library\n"
"time stamp\n"
"#Frame this data is associated with\n"
"string frame_id\n"
;
  }

  static const char* value(const ::planner_msgs::BehaviourPlannerLogger_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::planner_msgs::BehaviourPlannerLogger_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.total_time);
      stream.next(m.planner);
      stream.next(m.current_seen_ratio);
      stream.next(m.exploration_cost);
      stream.next(m.coverage_cost);
      stream.next(m.room_belief);
      stream.next(m.tunnel_belief);
      stream.next(m.perf_exp);
      stream.next(m.perf_cov);
      stream.next(m.delta_seen_surf);
      stream.next(m.delta_seen_vol);
      stream.next(m.image_brightness_utility);
      stream.next(m.utility_sparse);
      stream.next(m.utility_dense);
      stream.next(m.utility_corridor);
      stream.next(m.final_scores);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct BehaviourPlannerLogger_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::planner_msgs::BehaviourPlannerLogger_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::planner_msgs::BehaviourPlannerLogger_<ContainerAllocator>& v)
  {
    s << indent << "header: ";
    s << std::endl;
    Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "total_time: ";
    Printer<float>::stream(s, indent + "  ", v.total_time);
    s << indent << "planner: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.planner);
    s << indent << "current_seen_ratio: ";
    Printer<float>::stream(s, indent + "  ", v.current_seen_ratio);
    s << indent << "exploration_cost: ";
    Printer<float>::stream(s, indent + "  ", v.exploration_cost);
    s << indent << "coverage_cost: ";
    Printer<float>::stream(s, indent + "  ", v.coverage_cost);
    s << indent << "room_belief: ";
    Printer<float>::stream(s, indent + "  ", v.room_belief);
    s << indent << "tunnel_belief: ";
    Printer<float>::stream(s, indent + "  ", v.tunnel_belief);
    s << indent << "perf_exp: ";
    Printer<float>::stream(s, indent + "  ", v.perf_exp);
    s << indent << "perf_cov: ";
    Printer<float>::stream(s, indent + "  ", v.perf_cov);
    s << indent << "delta_seen_surf: ";
    Printer<float>::stream(s, indent + "  ", v.delta_seen_surf);
    s << indent << "delta_seen_vol: ";
    Printer<float>::stream(s, indent + "  ", v.delta_seen_vol);
    s << indent << "image_brightness_utility[]" << std::endl;
    for (size_t i = 0; i < v.image_brightness_utility.size(); ++i)
    {
      s << indent << "  image_brightness_utility[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.image_brightness_utility[i]);
    }
    s << indent << "utility_sparse[]" << std::endl;
    for (size_t i = 0; i < v.utility_sparse.size(); ++i)
    {
      s << indent << "  utility_sparse[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.utility_sparse[i]);
    }
    s << indent << "utility_dense[]" << std::endl;
    for (size_t i = 0; i < v.utility_dense.size(); ++i)
    {
      s << indent << "  utility_dense[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.utility_dense[i]);
    }
    s << indent << "utility_corridor[]" << std::endl;
    for (size_t i = 0; i < v.utility_corridor.size(); ++i)
    {
      s << indent << "  utility_corridor[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.utility_corridor[i]);
    }
    s << indent << "final_scores[]" << std::endl;
    for (size_t i = 0; i < v.final_scores.size(); ++i)
    {
      s << indent << "  final_scores[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.final_scores[i]);
    }
  }
};

} // namespace message_operations
} // namespace ros

#endif // PLANNER_MSGS_MESSAGE_BEHAVIOURPLANNERLOGGER_H
